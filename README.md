## Задание 1
> На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.
Пример:
```python
def isEven(value):
  return value % 2 == 0
```

Для решения задачи я использовал побитовый оператор &: выражение `number & 1` будет равняться 0 только в том случае, если number окажется четным. Приведенный мною алгоритм существенно быстрее того, что описан в задаче - если мы говорим о числах порядка 10^1000, для небольших чисел (< 1000) - скорость выполнения практически идентична. [Алгоритм и тесты быстродействия]

#### Плюсы алгоритма, описанного в задаче:
* Прост в понимании и реализации

#### Минусы:
* Более медленная скорость работы по сравнению алгоритмом '&'

#### Плюсы алгоритма с использованием побитового оператора &:
* Более быстрая скорость работы, для больших чисел - в несколько раз
* Прост в реализации

#### Минусы:
* Сложнее для понимания

## Задание 2
> На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Я реализовал 2 циклических буфера: один с помощью списка, другой с помощью связного списка. Прежде всего следует отметить, что в обоих случаях добавление и извлечение элемента осуществляется за O(1). Но так как память под буфер на списке уже выделена, добавление элемента в него происходит быстрее примерно на 70%-80%, чем аналогичная операция в буфере на связном списке. С другой стороны, извлечение элемента из буфера на списке медленнее извлечения из буфера на связном списке примерно на 20%, за счет более сложного алгоритма. [Реализация и тесты быстродействия]

#### Выводы:
* Память для буфера на списке выделяется в момент создания;
* Буфер на списке лучше применять, если требуется часто добавлять элементы;
* Буфер на связном списке больше подходит для извлечения элементов.

## Задание 3
> На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

Я думаю, что быстрая сортировка лучше всего подойдет для решения этой задачи. Несмотря на то что в худшем случае сортировка выполняется за O(n^2) и может уступать другим способам в некоторых тестах (полностью отсортированный массив, массив из малого числа элементов), она работает очень быстро (n log2n) и для приведенных данных `массив может быть любого размера со случайным порядком чисел` подойдет лучше всего. [Алгоритм]
